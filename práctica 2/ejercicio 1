{1.- Implementar un programa que invoque a los siguientes modulos.
a. Un modulo recursivo que retorne un vector de a lo sumo 15 numeros enteros random mayores a 10 y menores a 155 (incluidos ambos). La carga finaliza con 
el valor 20.
b. Un modulo no recursivo que reciba el vector generado en a) e imprima el contenido del vector.
c. Un modulo recursivo que reciba el vector generado en a) e imprima el contenido del vector.
d. Un modulo recursivo que reciba el vector generado en a) y devuelva la suma de los valores pares contenidos en el vector.
e. Un modulo recursivo que reciba el vector generado en a) y devuelva el maximo valor del vector.
f. Un modulo recursivo que reciba el vector generado en a) y un valor y devuelva verdadero si dicho valor se encuentra en el vector o falso en caso contrario.
g. Unmodulo que reciba el vector generado en a) e imprima, para cada numero contenido en el vector, sus digitos en el orden en que aparecen en el numero. 
Debe implementarse un modulo recursivo que reciba el numero e imprima lo pedido. Ejemplo si se lee el valor 142, se debe imprimir 1  4  2
}
program ejercicio1;
const
	dfvector = 15;
	corte = 20;

type
	rangovector = 1..dfvector;
	
	vector = array [rangovector] of integer;
	
procedure moduloincisoA(var v: vector; var dimlog: integer);
var
	aleatorio: integer;
begin
	aleatorio := random(146) + 10;
	if (aleatorio <> corte) and (dimlog < dfvector) then begin 
		dimlog := dimlog + 1;
		v[dimlog] := aleatorio;
		moduloincisoA(v, dimlog);	
	end;
end;

procedure moduloimprimeAnorecursivo(v: vector; dimlog: integer);
var
	i: rangovector;
begin
	for i := 1 to dimlog do 
		writeln('El numero en la posicion ', i , ' del vector, es: ', v[i]);
end;

procedure moduloimprimeArecursivo(v: vector; i, dimlog: integer);
begin
	if (i <= dimlog) then begin //check <=
		writeln('El numero en la posicion', i , 'del vector, es: ', v[i]);
		i := i + 1;
		moduloimprimeArecursivo(v, i, dimlog);
	end;
end;

function sumatotalD(v: vector; i, dimlog: rangovector): integer;
begin 
	if (i > dimlog) then 
		sumatotalD := 0
	else 
		if ((v[i] mod 2 )= 0) then  
			sumatotalD := v[i] + sumatotalD(v, i + 1, dimlog)
		else
			sumatotalD := sumatotalD(v, i + 1, dimlog);
end;

procedure buscomaximoE(v: vector; i, dimlog: integer; var maximovalor: integer);
begin
	if (i <= dimlog) then begin 
		if (maximovalor < v[i]) then  
			maximovalor := v[i];
		i := i + 1;
		buscomaximoE(v, i, dimlog, maximovalor);
	end;
end;

function buscarvalorF(v: vector; i, dimlog, valor: integer): boolean;
begin
	if (i <= dimlog) then begin 
		if(v[i] = valor) then 				
			buscarvalorF := true
		else
			buscarvalorF := buscarvalorF(v, i + 1, dimlog, valor);
	end
	else
		buscarvalorF := false; // si llega al final del vector (i > dimlog), es porque el elemento a buscar NO está
end;

procedure digitos(num: integer);
begin 
	if (num < 10) then 
		writeln(num)
	else begin
		digitos(num div 10);
		writeln(num mod 10);
	end;
end;
procedure imprimir(v: vector; dimlog: integer);
var
	i: rangovector;
begin 
	for i := 1 to dimlog do begin 	
		writeln('El número: ', v[i], ' descomponiendolo, quedaria: ');
		digitos(v[i]);
	end;
end;
			
// programa principal
var
	v: vector;
	i: rangovector;
	dimlog, maximovalor, valor: integer;
	sumatotal: integer;
	encontre: boolean;
begin
	Randomize;
	dimlog := 0;
	moduloincisoA(v, dimlog); // A
	moduloimprimeAnorecursivo(v, dimlog); // B
	i := 1;
	moduloimprimeArecursivo(v, i, dimlog); // C

	sumatotal := sumatotalD(v, i, dimlog); // D
	writeln('La suma total de los numeros pares del vector es: ', sumatotal);
	maximovalor := -1;
	buscomaximoE(v, i, dimlog, maximovalor); // E
	writeln('El maximo valor será: ', maximovalor);
// f. Un modulo recursivo que reciba el vector generado en a) y un valor y devuelva verdadero si dicho valor se encuentra en el vector o falso en caso contrario.
	writeln('Ingrese el valor para buscarlo en el vector de manera recursiva: ');
	readln(valor);
	encontre := buscarvalorF(v, i, dimlog, valor); 
	writeln('El valor: ', valor, ' tiene resultado booleano: ', encontre);
	imprimir(v, dimlog);
end.
