{El correo argentino necesita procesar los envios entregadores durante el mes de juio de 2024.
De cada envio se conoce, el codigo de cliente, el dia, el codigo postal y el peso del paquete.
A. Implementar un modulo que lea envios, genere y retorne un arbol ordenado por codigo postal, donde para cada codigo postal
se almacena en una lista todos los envios (codigo de cliente, dia y peso del paquete) correspondientes.
La lectura finaliza con el codigo de cliente 0. 
B. Implementar un modulo que reciba a estructura que se gener√≥ en A y un codigo postal, y retorne todos los envios de dicho codigo postal.
C. Realizar un  modulo recursivo que reciba la estructura que retorna el inciso B y retorne los dos codigos de cliente correspondientes
al envio con menor y mayor peso.}

program parcialCorreos;
const
	dfDia = 31;
	corte = 0;

type
	rangoDia = 1..dfDia;
	
	envio = record
		codigoCliente: integer;
		dia: rangoDia;
		codigoPostal: integer;
		peso: real;
	end;
	
	datosLista = record
		codigoCliente: integer;
		dia: rangoDia;
		peso: real;
	end;
	
	listaEnvios = ^nodoLista;
	nodoLista = record
		dato: datosLista;
		sig: listaEnvios;
	end;
	
	datosArbol = record
		codigoPostal: integer;
		lista: listaEnvios;
	end;
	
	arbol = ^nodoArbol;
	nodoArbol = record
		dato: datosArbol;
		HI: arbol; HD: arbol;
	end;
	
	
// MODULOS

// INICIO INCISO A 
	procedure leerEnvio(var e: envio);
	begin
		e.codigoCliente := random(50); 
		writeln('El codigo de cliente generado es: ', e.codigoCliente);
		if (e.codigoCliente <> corte) then begin 
			e.dia := random(31) + 1;
			writeln('El dia generado es: ', e.dia);
			e.codigoPostal := random(200) + 1;
			writeln('El codigo postal generado es: ', e.codigoPostal);
			e.peso := random(300)+ 10;
			writeln('El peso generado es: ', e.peso:0:2); writeln;
		end;
	end;
	
	procedure agregarAdelante(var l: listaEnvios; dL: datosLista);
	var
		nue: listaEnvios;
	begin
		new(nue);
		nue^.dato := dL;
		nue^.sig := l;
		l := nue;
	end;
	
	procedure agregarEnArbol(var a: arbol; codPostal: integer; dL: datosLista);
	begin
		if (a = nil) then begin 
			new(a);
			a^.dato.codigoPostal := codPostal;
			a^.dato.lista := nil;
			agregarAdelante(a^.dato.lista, dL);
			a^.HI := nil; a^.HD := nil;
		end
		else begin
			if (a^.dato.codigoPostal = codPostal) then 
				agregarAdelante(a^.dato.lista, dL)
			else begin
				if (a^.dato.codigoPostal > codPostal) then 
					agregarEnArbol(a^.HI, codPostal, dL)
				else
					agregarEnArbol(a^.HD, codPostal, dL);
			end;
		end;
	end;
	
	procedure cargarArbol(var a: arbol);
		procedure  cargarDatosLista(var dL: datosLista; e: envio);
		begin
			dL.codigoCliente := e.codigoCliente;
			dL.dia := e.dia;
			dL.peso := e.peso;
		end;
	var
		e: envio;
		dL: datosLista;
	begin
		leerEnvio(e);
		while (e.codigoCliente <> corte) do begin 
			cargarDatosLista(dL, e);
			agregarEnArbol(a, e.codigoPostal, dL);
			leerEnvio(e);
		end;
	end;
	
	procedure imprimirLista(l: listaEnvios);
	begin
		while (l <> nil) do begin
			writeln('El codigo de cliente es: ', l^.dato.codigoCliente); 
			writeln('El dia es: ', l^.dato.dia);
			writeln('Y el peso de paquete es: ', l^.dato.peso:0:2);
			writeln;
			l := l^.sig;
		end;
	end;
	procedure imprimirArbol(a: arbol);
	begin
		if (a <> nil) then begin 
			imprimirArbol(a^.HI);
			writeln('El codigo postal ', a^.dato.codigoPostal, ' tiene la siguiente lista de envios: ');
			imprimirLista(a^.dato.lista);
			writeln;
			imprimirArbol(a^.HD);
		end;
	end;
// FIN INCISO A

// INICIO INCISO B
	

	procedure cargarListaNueva(var l2: listaEnvios; l: listaEnvios);
		procedure agregarAdelante2(var l2: listaEnvios; dL: datosLista);
		var
			nue: listaEnvios;
		begin
			new(nue);
			nue^.dato := dL;
			nue^.sig := l2;
			l2 := nue;
		end;
	begin
		while (l <> nil) do begin 
			agregarAdelante2(l2, l^.dato);
			l := l^.sig;
		end;
	end;
	procedure retornoListaEnviosDelCPLeido(a: arbol; cp: integer; var l2: listaEnvios);
	begin
		if (a <> nil) then begin
			if (a^.dato.codigoPostal = cp) then 
				cargarListaNueva(l2, a^.dato.lista)
			else begin
				if (a^.dato.codigoPostal > cp) then 
					retornoListaEnviosDelCPLeido(a^.HI, cp, l2)
				else
					retornoListaEnviosDelCPLeido(a^.HD, cp, l2);
			end;
		end
		else	
			l2 := nil;
	end;
// FIN INCISO B

// INICIO INCISO C
	procedure retornoCodigosMinimoYMaximo(l2: listaEnvios; var codMin, codMax: integer);
		procedure recorroL2YBuscoMinMax(l2: listaEnvios; var codMin, codMax: integer; var minimo, maximo: real);
		begin
			if (l2 <> nil) then begin 
				if (l2^.dato.peso > maximo) then begin 
					maximo := l2^.dato.peso;
					codMax := l2^.dato.codigoCliente;
				end
				else begin
					minimo := l2^.dato.peso;
					codMin := l2^.dato.codigoCliente;
				end;
				recorroL2YBuscoMinMax(l2^.sig, codMin, codMax, minimo, maximo);
			end;
		end;
	var
		minimo, maximo: real;
	begin
		minimo := 9999; maximo := -1;
		recorroL2YBuscoMinMax(l2, codMin, codMax, minimo, maximo);
	end;
// FIN INCISO C

// PROGRAMA PRINCIPAL
var
	a: arbol;
	l2: listaEnvios;
	codPost, codigoClienteMinimo, codigoClienteMaximo: integer;
begin			
	Randomize;
	a := nil;
	cargarArbol(a);
	writeln('/////////////////////////////////////////////////////////');
	writeln('El arbol impreso quedaria de la siguiente manera: '); imprimirArbol(a); writeln;
	
	
	writeln('Ingrese un codigo postal para retornar una lista de los envios de dicho codigo: '); readln(codPost);
	l2 := nil;
	retornoListaEnviosDelCPLeido(a, codPost, l2);
	writeln; writeln('El/Los envio/s del codigo postal ', codPost, ' es/son lo/s siguiente/s: '); imprimirLista(l2);
	writeln('/////////////////////////////////////////////////////////');
	
	codigoClienteMinimo := 0;
	codigoClienteMaximo := 0;
	retornoCodigosMinimoYMaximo(l2, codigoClienteMinimo, codigoClienteMaximo);
	writeln ('El codigo de cliente minimo de la lista de envios 2 es: ', codigoClienteMinimo, ' y el maximo es: ', codigoClienteMaximo);
	
end.
