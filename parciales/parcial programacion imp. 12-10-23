{El teatro Musicalisimo ofrece sus instalaciones para que bandas de música puedan dar sus recitales. De cada recital se conoce: 
el nombre de la banda, la fecha del recital, la cantidad de canciones tocadas y el monto recaudado por la venta de entradas.
a. Implemente un módulo que lea registros de recitales de manera sucesiva hasta que se ingrese "ZZZ" como nombre de banda. 
Los recitales se pueden leer en cualquier orden. Todos los recitales leidos deben almacenarse en ua estructura que permita 
el recorrido óptimo por monto recaudado.
b. Implemente un módulo que reciba la estructura cargada y dos valores (ej: 200 y 500) y devuelva una lista con todos los
recitales cuyo monto recaudado se encuentra entre esos dos valores leídos (ambas inclusive). La lista
resultante debe estar ordenada por monto de mayor a menor.
c. Implemente un módulo recursivo que reciba la lista creada en b) y devuelva la cantidad de recitales que tocaron
más de 12 canciones}
program parcialTeatro;
const	
	corte = 'ZZZ';

type

	date = record
		dia: integer;
		mes:integer;
		anio: integer;
	end;
	
	recital = record
		nombreBanda: string;
		fecha: date;
		cantidadCanciones: integer;
		monto: real;
	end;
	
	arbol = ^nodo;
	nodo = record
		dato: recital;
		HI: arbol;
		HD: arbol;
	end;
	
	lista = ^nodo2;
	nodo2 = record
		dato: recital;
		sig: lista;
	end;
	
// MÓDULOS	
	
// INICIO A	
	procedure leerRecital(var r: recital);
		procedure leerFecha(var d: date);
		begin
			d.dia:= random(31) + 1;
			d.mes := random(12) + 1;
			d.anio := 2023;
		end;
	begin
		readln(r.nombreBanda);
		if (r.nombreBanda <> corte) then begin 
			leerFecha(r.fecha);
			r.cantidadCanciones := random(15) + 1;
			r.monto := random (20000) + 1500;
		end;
	end;
	
	procedure agregar(var a: arbol; r: recital);
	begin
		if (a = nil) then begin 
			new(a);
			a^.dato := r;
			a^.HI := nil; a^.HD := nil;
		end
		else begin
			if (a^.dato.monto > r.monto) then 
				agregar(a^.HI, r)
			else
				agregar(a^.HD, r);
		end;
	end;
	
	procedure cargarArbol(var a: arbol);
	var
		r: recital;
	begin
		leerRecital(r);
		while (r.nombreBanda <> corte) do begin 
			agregar(a, r);
			leerRecital(r);
		end;
	end;
// FIN A	
	
// INICIO B
	procedure insertarOrdenado(var l: lista; r: recital);
	var
		nue, act, ant: lista;
	begin
		new(nue);
		nue^.dato := r;
		act := l;
		while (act <> nil) and (act^.dato.monto > r.monto) do begin // mayor a menor
			ant := act;
			act := act^.sig;
		end;
		if (act = l) then 
			l := nue
		else
			ant^.sig := nue;
		nue^.sig := act;
	end;
	
	procedure retornoLista(a: arbol; v1, v2: integer; var l: lista);
	begin 
		if (a <> nil) then begin
			if (a^.dato.monto >= v1) then begin
				if (a^.dato.monto <= v2) then 
					insertarOrdenado(l, a^.dato);
					retornoLista(a^.HI, v1, v2, l);
					retornoLista(a^.HD, v1, v2, l)
				else
					retornoLista(a^.HI, v1, v2, l);
			end		
			else
				retornoLista(a^.HD, v1, v2, l);
		end;
	end;
// FIN B
	
// INICIO C

	function retornoCantRecCumlen(l : lista): integer;
	begin
		if (l = nil) then 	
			retornoCantRecCumlen := 0
		else
			if (l^.dato.cantidadCanciones > 12) then 
				retornoCantRecCumlen := 1 + retornoCantRecCumlen(l^.sig);
			else
				retornoCantRecCumlen := retornoCantRecCumlen(l^.sig);
	end;

// FIN C	
	
// programa principal
var
	a: arbol;
	l: lista;
	valor1, valor2, cantRec: integer;
	
begin 
	Randomize;
	a :=  nil;
	cargarArbol(a);
	
	l := nil;
	readln(valor1); readln(valor2);
	retornoLista(a, valor1, valor2, l);
	
	cantRec := retornoCantRecCumlen(l);
end.
