{Se lee informacion de las compras realizadas por los clientes a un supermercado en 2023.
De las compras se conoce el codigo de cliente, el numero de factura, el numero del mes y el monto total gastado.
La lectura finaliza cuando se lee el cliente con código 0.
A. realice un modulo que lea informacion de las compras y retorne un abb  ordenado por codigo de cliente. Para cada codigo de cliente, se debe
almacenar un vector con el monto total gastado por dicho cliente en cada mes del año.
B. realizar un modulo que reciba la estrctura generada en A y un codigo de cliente, y retorne el mes con mayor gasto de dicho cliente.
C. realizar un modulo que reciba la estructura generada en A y un mes, y retorne la cantidad de clientes que no gastaron nada en dicho mes.}

program parcialTurnoL;
const
	corte = 0;
	dfMes = 12;
type
	rangoMes = 1..dfMes;
	
	compra = record
		codigoCliente: integer;
		numeroFactura: integer;
		mes: rangoMes;
		montoGastado: real;
	end;
	
	vectorMontos = array [rangoMes] of real;
	
	datosArbol = record
		codigoCliente: integer;
		vec: vectorMontos;
	end;
	
	arbol = ^nodo;
	nodo = record
		dato: datosArbol;
		HI: arbol;
		HD: arbol;
	end;
	
	
// MÓDULOS

// INICIO INCISO A
	procedure leerCompra(var c: compra);
	begin
		c.codigoCliente := random(20);
		writeln('El codigo de cliente de la compra es: ', c.codigoCliente);
		if (c.codigoCliente <> corte) then begin
			c.numeroFactura := random(300) + 100;
			writeln('El numero de factura de la compra es: ', c.numeroFactura);
			c.mes := random(12) + 1;
			writeln('El mes de la compra es: ', c.mes);
			c.montoGastado := random(1000) + 500;
			writeln('El monto gastado de la compra es: ', c.montoGastado:0:2);
		end;
	end;
	
	procedure inicializarVectorMontos(var v: vectorMontos);
	var
		i: rangoMes;
	begin
		for i := 1 to dfMes do 
			v[i] := 0;
	end;

	procedure agregar(var a: arbol; c: compra);
	begin
		if (a = nil) then begin
			new(a);
			a^.dato.codigoCliente := c.codigoCliente;
			inicializarVectorMontos(a^.dato.vec);
			a^.dato.vec[c.mes] := c.montoGastado;
			a^.HI := nil;
			a^.HD := nil;
		end
		else begin
			if (a^.dato.codigoCliente = c.codigoCliente) then 
				a^.dato.vec[c.mes] := a^.dato.vec[c.mes] + c.montoGastado
			else begin
				if (a^.dato.codigoCliente > c.codigoCliente) then 
					agregar(a^.HI, c)
				else
					agregar(a^.HD, c);
			end;
		end;		
	end;
	
	procedure cargarArbol(var a: arbol);
	var
		c: compra;
	begin 
		leerCompra(c);
		while (c.codigoCliente <> corte) do begin 
			agregar(a, c);
			leerCompra(c);
		end;
	end;
	
	procedure mostrarArbol(a: arbol);
		
		procedure mostrarVectorMontos(v: vectorMontos);
		var
			i: rangoMes;
		begin 
			for i := 1 to dfMes do 
				writeln ('El mes: ', i , ' tuvo un monto total gastado de: ' , v[i]:0:2);
		end;
	begin
		if (a <> nil) then begin 
			mostrarArbol(a^.HI);
			writeln('El código de cliente es: ', a^.dato.codigoCliente);
			mostrarVectorMontos(a^.dato.vec);
			mostrarArbol(a^.HD);
		end;
	end;
// FIN INCISO A

// INICIO INCISO B
	function retornoMayorMes(a: arbol; codcli: integer): integer;
	
		function buscoMaximoMes(v: vectorMontos): integer;
		var
			i: rangoMes;
			maxMes: integer;
			maxMonto: real;
		begin
			maxMonto := -1;
			maxMes := 0;
			for i := 1 to dfMes do begin 
				if (maxMonto < v[i]) then begin 
					maxMonto := v[i];
					maxMes := i;
				end;
			end;
			buscoMaximoMes := maxMes;
		end;
		
	begin 
		if (a <> nil) then begin 
			if (a^.dato.codigoCliente = codcli) then 
				retornoMayorMes := buscoMaximoMes(a^.dato.vec)
			else begin
				if (a^.dato.codigoCliente > codcli) then 
					retornoMayorMes := retornoMayorMes(a^.HI, codcli)
				else
					retornoMayorMes := retornoMayorMes(a^.HD, codcli)
			end;
		end
		else
			retornoMayorMes := -1;
	end;
// FIN INCISO B

// INICIO INCISO C
// C. realizar un modulo que reciba la estructura generada en A y un mes, y retorne la cantidad de clientes que no gastaron nada en dicho mes
		function retornoCantidadSinGastar(a: arbol; mesleido: rangoMes): integer;
			
			function cantNoGastaron (v: vectorMontos; mesleido: integer): integer;
			begin 
				if (v[mesleido] = 0) then 
					cantNoGastaron := 1
				else
					cantNoGastaron := 0;
			end;
			
		begin 
			if (a = nil) then 	
				retornoCantidadSinGastar := 0
			else
				retornoCantidadSinGastar := cantNoGastaron(a^.dato.vec, mesleido) + retornoCantidadSinGastar(a^.HI, mesleido) + retornoCantidadSinGastar(a^.HD, mesleido);
		end;	

// FIN INCISO C


// PROGRAMA PRINCIPAL

var
	a: arbol;
	maximomes, month: rangoMes;
	cantidadSinGastar, codcli: integer;
begin 
	Randomize;
	a := nil;
	cargarArbol(a); // A
	writeln('El arbol cargado quedaría de la siguiente manera: ');
	mostrarArbol(a); // NO LO PIDE. solo para compilar y ver la ejecución.
	
	writeln('Ingrese un codigo de cliente para buscar el mes con mayor gastos: ');
	readln(codcli); 
	maximomes := retornoMayorMes(a, codcli); // B // Si pongo un numero q no está me devuelve 145.
	writeln('El mes maximo con mas gastos es: ', maximomes); // NO LO PIDE. 
	
	writeln('Ingrese un mes para buscar la cantidad de clientes que no gastaron nada en dicho mes: ');
	readln(month);
	cantidadSinGastar := retornoCantidadSinGastar(a, month); // C
	writeln('La cantidad de clientes que no gastaron nada en el mes ', month, ' fueron: ', cantidadSinGastar); // NO LO PIDE.
end.
