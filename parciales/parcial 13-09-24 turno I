{Una empresa de alquiler de autos desea procesar la información de sus alquileres.
a) Implementar un módulo que lea información de los alquileres y retorne un vector que agrupe los alquileres de acuerdo a la cantidad de días de alquiler. Para cada cantidad de días, los alquileres deben almacenarse en un
árbol binario de búsqueda ordenado por número de chasis del auto.
De cada alquiler se lee: dni del cliente, número de chasis y cantidad de días (de 1 a 7). La lectura finaliza con el número de chasis 0.
b)
Implementar un módulo que reciba la estructura generada en a) y un dni D. Este módulo debe retornar la cantidad de alquileres realizados por el dni D.
Implementar un módulo que reciba la estructura generada en a), un día D y dos números de chasis N1 y N2.
Este módulo debe retornar la cantidad de alquileres realizados en el día D, para los chasis entre N1 y N2 (ambos incluidos).}
program parcialturnoI;
const
	dfDia = 7;
	corte = 0;

type
	rangoDia = 1..dfDia;
	
	alquiler = record
		dniCliente: integer;
		numeroChasis: integer;
		cantidadDias: rangoDia;
	end;
	
	datosArbol = record
		dniCliente: integer;
		numeroChasis: integer;
	end;
	
	arbol = ^nodo;
	nodo = record
		dato: datosArbol;
		HI: arbol;
		HD: arbol;
	end;

	vector = array [rangoDia] of arbol;
	
	
// MODULOS

// INICIO INCISO A
	procedure leerAlquiler(var alq: alquiler);
	begin 
		alq.numeroChasis := random(200);
		if (alq.numeroChasis <> corte) then begin 
			alq.dniCliente := random(7000) + 1;
			alq.cantidadDias := random(7) + 1;
		end;
	end;
	
	procedure inicializarVector(var v: vector);
	var
		i: rangoDia;
	begin
		for i := 1 to dfDia do 
			v[i] := nil;
	end;
	
	procedure agregarEnArbol(var a: arbol; dA: datosArbol);
	begin
		if (a = nil) then begin
			new(a);
			a^.dato := dA;
			a^.HI := nil;
			a^.HD := nil;
		end
		else begin 
			if (a^.dato.numeroChasis > dA.numeroChasis) then 
				agregarEnArbol(a^.HI, dA)
			else
				agregarEnArbol(a^.HD, dA);
		end;
	end;			
	
	procedure cargarVector(var v: vector);
		procedure cargarDatosArbol(var dA: datosArbol; alq: alquiler);
		begin
			dA.dniCliente := alq.dniCliente;
			dA.numeroChasis := alq.numeroChasis;
		end;
	var
		alq: alquiler;
		dA: datosArbol;
	begin
		leerAlquiler(alq);
		while (alq.numeroChasis <> corte) do begin 
			cargarDatosArbol(dA, alq);
			agregarEnArbol(v[alq.cantidadDias], dA);
			leerAlquiler(alq);
		end;
	end;
// FIN INCISO A
	
// INICIO INCISO B 
	function retornoCantidadAlqPorDni(v: vector; dni: integer): integer;
		function cantidadEnElArbol(a: arbol; dni: integer): integer;
		begin
			if (a <> nil) then begin
				if (a^.dato.dniCliente = dni) then 
					cantidadEnElArbol := 1 + cantidadEnElArbol(a^.HI, dni) + cantidadEnElArbol(a^.HD, dni)
				else
					cantidadEnElArbol := cantidadEnElArbol(a^.HI, dni) + cantidadEnElArbol(a^.HD, dni);
			end
			else
				cantidadEnElArbol := 0
		end;
	
	var
		i: rangoDia; cantAlq: integer;
	begin
		cantAlq := 0;
		for i := 1 to dfDia do 
			if (v[i] <> nil) then // pero dsp en cantidadEnElArbol volveria a preguntar (????)
				cantAlq := cantAlq + cantidadEnElArbol(v[i], dni);
		retornoCantidadAlqPorDni := cantAlq;
	end;
// FIN INCISO B	
	
// INICIO INCISO C	
	function cumpleDiaLeido(dia: integer): boolean;
	begin
		if (dia >= 1) and (dia <= 7) then 
			cumpleDiaLeido := true
		else
			cumpleDiaLeido := false;
	end;
		
	function retornoCantEntreNum(v: vector; dia: integer; numChasis1, numChasis2: integer): integer;
		
		function retornoAlquileres(a: arbol; numChasis1, numChasis2: integer): integer;
		begin
			if (a = nil) then 
				retornoAlquileres := 0
			else begin
				if (a^.dato.numeroChasis >= numChasis1) then begin
					if (a^.dato.numeroChasis <= numChasis2) then 
						retornoAlquileres := 1 + retornoAlquileres(a^.HI, numChasis1, numChasis2) + retornoAlquileres(a^.HD, numChasis1, numChasis2)
					else
						retornoAlquileres := retornoAlquileres(a^.HI, numChasis1, numChasis2);
				end
				else
					retornoAlquileres := retornoAlquileres(a^.HD, numChasis1, numChasis2);
			end;
		end;
		
	begin
		retornoCantEntreNum := retornoAlquileres(v[dia], numChasis1, numChasis2);
	end;
// FIN INCISO C

// PROGRAMA PRINCIPAL
var
	v: vector;
	dni, cantIncisoB, dia, numeroChasis1, numeroChasis2, cantIncisoC: integer;
begin
	Randomize;
	inicializarVector(v);
	cargarVector(v);
	
	readln(dni);
	cantIncisoB := retornoCantidadAlqPorDni(v, dni);
	
	readln(numeroChasis1); readln(numeroChasis2); readln(dia);
	if (cumpleDiaLeido(dia)) then
		cantIncisoC := retornoCantEntreNum(v, dia, numeroChasis1, numeroChasis2)
	else
		writeln('El dia ingresado no cumple el rango de dias.');
end.
