{La Feria del Libro necesita un sistema para obtener estadísticas sobre los libros presentados.
a) Implementar un módulo que lea información de los libros. De cada libro se conoce: ISBN, código del autor y código del género (1: literario, 2: filosofía, 3: biología, 4: arte, 5: computación, 6: medicina, 7: ingeniería). La lectura finaliza con el valor 0 para el ISBN. Se sugiere utilizar el módulo leerlibro(). El módulo deber retornar dos estructuras:
I. Un árbol binario de búsqueda ordenado por código de autor. Para cada código de autor debe almacenarse la
cantidad de libros correspondientes al código.
ii. Un vector que almacene para cada género, el código del género y la cantidad de libros del género.
b) Implementar un módulo que reciba el vector generado en a), lo ordene por cantidad de libros de mayor a menor
y retorne el nombre de género con mayor cantidad cantidad de libros.
C) Implementar un módulo que reciba el árbol generado en a) y dos códigos. El módulo debe retornar la cantidad total de libros correspondientes a los códigos de autores entre los dos códigos ingresados (incluidos ambos).}
program parcialturnoE;
const
	dfGenero = 7;
	corte = 0;
	
type
	rangoGenero = 1..dfGenero;
	
	libro = record
		isbn: integer;
		codigoAutor: integer;
		genero: rangoGenero;
	end;
	
	datosArbol = record
		codigoAutor: integer;
		cantidadLibrosAutor: integer;
	end;
	
	arbol = ^nodo;
	nodo = record
		dato: datosArbol;
		HI: arbol;
		HD: arbol;
	end;
	
	datosVector = record
		genero: rangoGenero;
		cantidadLibrosGenero: integer;
	end;
	
	vectorGeneros = array[rangoGenero] of datosVector;
	
	
// MODULOS

// INICIO A
	procedure inicializarVectorGeneros(var v: vectorGeneros);
	var
		i: rangoGenero;
	begin
		for i := 1 to dfGenero do begin
			v[i].genero := i;
			v[i].cantidadLibrosGenero := 0;
		end;
	end;
	
	procedure leerLibro(var li: libro);
	begin
		li.isbn := random(10);
		if (li.isbn <> corte) then begin 
			li.codigoAutor := random(200) + 1;
			li.genero := random(7) + 1;
		end;
	end;
	
	procedure agregarEnArbol(var a: arbol; codAut: integer);
	begin
		if (a = nil) then begin 
			new(a);
			a^.dato.codigoAutor := codAut;
			a^.dato.cantidadLibrosAutor := 1;
			a^.HI := nil; a^.HD := nil;
		end
		else begin
			if (a^.dato.codigoAutor = codAut) then 
				a^.dato.cantidadLibrosAutor := a^.dato.cantidadLibrosAutor + 1
			else begin 
				if (a^.dato.codigoAutor > codAut) then 
					agregarEnArbol(a^.HI, codAut)
				else
					agregarEnArbol(a^.HD, codAut);
				
				end;
		end;
	end;
	
	procedure agregarEnVector(var v: vectorGeneros; gen: rangoGenero);
	begin
		v[gen].cantidadLibrosGenero := v[gen].cantidadLibrosGenero + 1; 
	end;
	
	procedure cargarEstructuras(var a: arbol; var v: vectorGeneros);
	var
		li: libro;
	begin
		leerLibro(li);
		while(li.isbn <> corte) do begin 
			agregarEnArbol(a, li.codigoAutor);
			agregarEnVector(v, li.genero);
			leerLibro(li);
		end;
	end;
// FIN A
// INICIO NO PIDE A
	procedure imprimirArbol(a: arbol);
	begin
		if (a <> nil) then begin 
			imprimirArbol(a^.HI);
			writeln('El codigo de autor es: ', a^.dato.codigoAutor, ' y tiene una cantidad de libros de: ', a^.dato.cantidadLibrosAutor);
			writeln('');
			imprimirArbol(a^.HD);
		end;
	end;
	procedure imprimirVector(v: vectorGeneros);
	var 
		i: rangoGenero;
	begin 
		for i := 1 to dfGenero do begin
			writeln('El genero ', i, ' tiene una cantidad de libros de: ', v[i].cantidadLibrosGenero);
			writeln('');
		end;
	end;
// FIN NO PIDE A

// INICIO INCISO B
	procedure ordenarVector(var v: vectorGeneros; var nombreGeneroMax: string);
	var
		i, j: integer;
		act: datosVector;
		vNombres: array [rangoGenero] of string = ('Literario', 'Filosofia', 'Biologia', 'Arte', 'Computacion', 'Medicina', 'Ingenieria');
	begin
		for i := 2 to dfGenero do begin 
			act := v[i];
			j := i - 1;
			while (j > 0) and (v[j].cantidadLibrosGenero < act.cantidadLibrosGenero) do begin 
				v[j + 1] := v[j];
				j := j - 1;
			end;
			v[j + 1] := act;
		end;
		nombreGeneroMax := vNombres[v[1].genero];
	end;
// FIN INCISO B

// INICIO INCISO C
	function retornoCantidadEntreRango(a: arbol; cod1, cod2: integer): integer;
	begin
		if (a = nil) then 	
			retornoCantidadEntreRango := 0
		else begin 
			if (a^.dato.codigoAutor >= cod1) then begin 
				if (a^.dato.codigoAutor <= cod2) then 
					retornoCantidadEntreRango := a^.dato.cantidadLibrosAutor + retornoCantidadEntreRango(a^.HI, cod1, cod2) + retornoCantidadEntreRango(a^.HD, cod1, cod2)
				else
					retornoCantidadEntreRango := retornoCantidadEntreRango(a^.HI, cod1, cod2);
			end
			else
				retornoCantidadEntreRango := retornoCantidadEntreRango(a^.HD, cod1, cod2);
		end;
	end;



// PROGRAMA PRINCIPAL

var
	a: arbol;
	v: vectorGeneros;
	nombreGeneroMaximo: string;
	codigo1, codigo2, cantTot: integer;
begin
	Randomize;
	a := nil;
	inicializarVectorGeneros(v);
	cargarEstructuras(a, v); // A
	writeln('El arbol quedaria de la siguiente manera: '); imprimirArbol(a); // NO PIDE A
	writeln('Y el vector asi: '); imprimirVector(v); // NO PIDE A
	
	nombreGeneroMaximo := '';
	ordenarVector(v, nombreGeneroMaximo); // B	
	writeln('El vector ordenado quedaria de la siguiente manera: '); // NO PIDE B
	imprimirVector(v); // NO PIDE B
	writeln('El nombre del genero maximo es: ', nombreGeneroMaximo); // NO PIDE B
	
	writeln('Ingrese un codigo, considerelo como el limite inferior de un rango: ');
	readln(codigo1);
	writeln('Ingrese otro codigo, considerelo como el limite superior de un rango, debe ser mayor al ingresado anteriormente: ');
	readln(codigo2);
	cantTot := retornoCantidadEntreRango(a, codigo1, codigo2); // C
	writeln('La cantidad total de codigos de autores dentro del rango ', codigo1, ' y ', codigo2, ' son: ', cantTot); // NO PIDE C
end.
